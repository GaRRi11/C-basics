1 uint16_t
// Specifies the return type: the 16-bit Internet checksum.
2 in_cksum(uint16_t *addr, int len)
// Defines the function to calculate the Internet checksum.
3 {
4 int nleft = len;
// Initializes the remaining length (in bytes) to be checksummed.
5 uint32_t sum = 0;
// Accumulator for the 1's complement sum (must be 32-bit to handle carries).
6 uint16_t *w = addr;
// Pointer to iterate through the data as 16-bit words.
7 uint16_t answer = 0;
// Variable to hold the final 16-bit checksum (1's complement of the sum).

8 /* ... comments explaining the algorithm ... */

13 while (nleft > 1) {
// Loop to add 16-bit words until 0 or 1 byte remains.
14 sum += *w++;
// Adds the current 16-bit word to the accumulator and increments the word pointer.
15 nleft -= 2;
// Decrements the remaining length by 2 bytes.
16 }

17 /* mop up an odd byte, if necessary */
// Handles the case where the data length is odd (the last byte needs to be included).
18 if (nleft == 1) {
// Checks if exactly one byte is left.
19 *(unsigned char *) (&answer) = *(unsigned char *) w;
// Moves the remaining byte (pointed to by `w`) into the low-order byte of `answer`,
// padding the high-order byte with zero (logical zero-padding).
20 sum += answer;
// Adds the padded 16-bit value to the accumulator.
21 }

22 /* add back carry outs from top 16 bits to low 16 bits */
// Folds the carry bits (the higher 16 bits) back into the lower 16 bits.
23 sum = (sum >> 16) + (sum & 0xffff);
// Adds the carry bits (top 16 bits) to the lower 16 bits.
24 sum += (sum >> 16);
// Performs a second fold to capture any new carry generated by the previous addition.

25 answer = ~sum;
// Calculates the 1's complement of the final sum, which is the checksum.
26 return (answer);
// Returns the final 16-bit Internet checksum.
27 }
