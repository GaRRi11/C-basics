
IPv6 Socket Address Structure

struct in6_addr {
    uint8_t s6_addr[16];  // 128-bit IPv6 address
};


in6_addr holds a 16-byte IPv6 address in network byte order (big endian).

struct sockaddr_in6 {
    uint8_t       sin6_len;        // length of this structure
    sa_family_t   sin6_family;     // AF_INET6
    in_port_t     sin6_port;       // transport layer port number (network byte order)
    uint32_t      sin6_flowinfo;   // flow label + reserved bits
    struct in6_addr sin6_addr;     // IPv6 address (network byte order)
    uint32_t      sin6_scope_id;   // identifies the scope zone/interface
};

actual IPv6 socket address structure.

sin6_scope_id identifies which interface an IPv6 address belongs to. this required only for interface unique LLA s. not for GUA s. sin6_scope_id tells kernel which interface the LLA belogns to. every interface has its own LLA, So the kernel needs to know which interface’s link-local network you want. BUT for GUA specifing interface index not needed because GUA is valid for all interfaces.

addr.sin6_scope_id = if_nametoindex("eth0"); 

assigns sin6_scope_id the index of the interface. for example: 2 or 3.

port and addr fields converted to big-endian as always.

real example of defining sockaddr_in6 with real values:

#include <string.h>
#include <netinet/in.h>
#include <net/if.h>

struct sockaddr_in6 addr;
memset(&addr, 0, sizeof(addr));     // Always clear the struct

addr.sin6_family   = AF_INET6;      // Address family = IPv6
addr.sin6_port     = htons(8080);   // TCP/UDP port in network byte order
inet_pton(AF_INET6,
          "fe80::1234:abcd:5678:9abc",
          &addr.sin6_addr);         // Store IPv6 address (network byte order)

addr.sin6_flowinfo = 0;             // Not used normally
addr.sin6_scope_id = if_nametoindex("eth0");   // REQUIRED for link-local



sockaddr_storage

this is created for ensuring it can store any type of addr. (address only not other details like port and etc..).  example:

/* illustrative — actual system definition is implementation dependent */
#include <stdint.h>
#include <sys/types.h>    /* for sa_family_t */
#include <stddef.h>

#define _SS_SIZE 128               /* total size (common choice) */
#define _SS_ALIGNMENT sizeof(long long) /* strictest alignment we want */

struct sockaddr_storage {
    uint8_t     ss_len;                   /* BSD: length of struct (optional) */
    sa_family_t ss_family;                /* address family (AF_INET, AF_INET6, ...) */

    /* Force alignment: a member with the largest alignment requirement. */
    long long   _ss_align;                /* ensures proper alignment on 64-bit */

    /* Padding to make the whole struct _SS_SIZE bytes long.
       The exact size here depends on sizeof(ss_len)+sizeof(ss_family)+sizeof(_ss_align). */
    char        _ss_pad[_SS_SIZE
                        - sizeof(uint8_t)
                        - sizeof(sa_family_t)
                        - sizeof(long long)];
};


accept() example:

struct sockaddr_storage client;        // Large generic container for ANY socket address (IPv4, IPv6, etc.)
socklen_t len = sizeof(client);        // Must tell accept() how much space we provide

// accept() fills 'client' with the peer's address and returns a new connected socket FD
int connfd = accept(listenfd, (struct sockaddr *)&client, &len);
// NOTE: cast to (struct sockaddr*) is required because accept() uses old POSIX API

// Determine what kind of address the client has (IPv4 or IPv6)
if (client.ss_family == AF_INET) {

    // Safe to reinterpret 'client' as sockaddr_in because ss_family says it's IPv4
    struct sockaddr_in *ipv4 = (struct sockaddr_in *)&client;

    // Now you can access:
    // ipv4->sin_addr      (32-bit IPv4 address in network byte order)
    // ipv4->sin_port      (16-bit port in network byte order)
    // Convert to readable forms using inet_ntop(), ntohs(), etc.
}
else if (client.ss_family == AF_INET6) {

    // Safe to treat 'client' as IPv6 address
    struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)&client;

    // Now you can access:
    // ipv6->sin6_addr     (128-bit IPv6 address)
    // ipv6->sin6_port     (port)
    // ipv6->sin6_scope_id (interface index for link-local addresses)
}








when process sends an address structure to the kernel

functions which send address structure to the kernel like: process -> kernel

bind()
connect()
sendto()


in this case kernel needs to know WHERE the structure is (pointer) HOW MANY BYTES to copy from user space (size value)
so we craft a struct and make kernel copy bytes in that struct that way.



when the kernel returns an address structure to the process

functions like: kernel → process.

accept()

recvfrom()

getsockname()

getpeername()

These return address information (peer address, local address, sender address, etc).

You tell the kernel how much memory space you are giving it (so it doesn't overflow).
The kernel tells you how many bytes it actually wrote into the structure.

“Here is a buffer with X bytes available — don’t overflow.”
“I filled Y bytes (Y may be less than or equal to X).”



Process -> kernel example:

#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>

int main() {
    int sockfd = socket(AF_INET, SOCK_STREAM, 0); 
    // Create IPv4 TCP socket

    struct sockaddr_in serv;      
    // Create IPv4 socket address structure

    memset(&serv, 0, sizeof(serv));    
    // Always clear the structure (good practice)

    serv.sin_family = AF_INET;        
    // AF_INET = IPv4

    serv.sin_port = htons(8080);      
    // Port in NETWORK byte order

    inet_pton(AF_INET, "192.168.1.10", &serv.sin_addr);
    // Convert text → binary IPv4 and store it

    connect(sockfd, (struct sockaddr *)&serv, sizeof(serv));
    // process -> kernel:
    // 1) pass pointer to serv
    // 2) pass size (value) sizeof(serv)
    // kernel reads exactly sizeof(serv)

    close(sockfd);
}



Kernel -> Process example:

#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>

int main() {
    int listenfd = socket(AF_INET6, SOCK_STREAM, 0);
    // Create IPv6 TCP socket

    struct sockaddr_in6 serv;
    memset(&serv, 0, sizeof(serv));

    serv.sin6_family = AF_INET6;
    serv.sin6_port = htons(8080);
    serv.sin6_addr = in6addr_any;

    bind(listenfd, (struct sockaddr *)&serv, sizeof(serv));
    listen(listenfd, 5);

    struct sockaddr_storage client;  
    // Large generic container for ANY address type

    socklen_t len = sizeof(client);
    // VALUE: "kernel, here is the max size you may write"

    int connfd = accept(listenfd, (struct sockaddr *)&client, &len);
    // kernel -> process:
    // kernel fills 'client' with peer address
    // kernel writes ACTUAL size into len (RESULT)

    if (client.ss_family == AF_INET6) {
        struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)&client;

        char str[INET6_ADDRSTRLEN];
        inet_ntop(AF_INET6, &ipv6->sin6_addr, str, sizeof(str));
        printf("Client IPv6: %s\n", str);
    }

    close(connfd);
    close(listenfd);
}
